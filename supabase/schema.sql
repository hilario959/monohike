create table if not exists public.hikes (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  name text,
  comment text,
  started_at timestamptz not null,
  ended_at timestamptz not null,
  duration_sec integer not null,
  distance_meters double precision not null,
  created_at timestamptz not null default now()
);

alter table public.hikes add column if not exists comment text;

create index if not exists hikes_user_id_idx on public.hikes (user_id);

create table if not exists public.points (
  id bigint generated by default as identity primary key,
  hike_id bigint not null references public.hikes(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  lat double precision not null,
  lon double precision not null,
  timestamp timestamptz not null,
  accuracy double precision not null
);

create index if not exists points_hike_id_idx on public.points (hike_id);
create index if not exists points_user_id_idx on public.points (user_id);

alter table public.hikes enable row level security;
alter table public.points enable row level security;

create policy "hikes_select_own" on public.hikes
  for select using (auth.uid() = user_id);
create policy "hikes_insert_own" on public.hikes
  for insert with check (auth.uid() = user_id);
create policy "hikes_update_own" on public.hikes
  for update using (auth.uid() = user_id);
create policy "hikes_delete_own" on public.hikes
  for delete using (auth.uid() = user_id);

create policy "points_select_own" on public.points
  for select using (auth.uid() = user_id);
create policy "points_insert_own" on public.points
  for insert with check (auth.uid() = user_id);
create policy "points_delete_own" on public.points
  for delete using (auth.uid() = user_id);

create table if not exists public.hike_photos (
  id bigint generated by default as identity primary key,
  hike_id bigint not null references public.hikes(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  path text not null,
  is_cover boolean not null default false,
  created_at timestamptz not null default now()
);

create index if not exists hike_photos_hike_id_idx on public.hike_photos (hike_id);
create index if not exists hike_photos_user_id_idx on public.hike_photos (user_id);
create unique index if not exists hike_photos_cover_idx on public.hike_photos (hike_id) where is_cover;

alter table public.hike_photos enable row level security;

create policy "hike_photos_select_own" on public.hike_photos
  for select using (auth.uid() = user_id);
create policy "hike_photos_insert_own" on public.hike_photos
  for insert with check (auth.uid() = user_id);
create policy "hike_photos_update_own" on public.hike_photos
  for update using (auth.uid() = user_id);
create policy "hike_photos_delete_own" on public.hike_photos
  for delete using (auth.uid() = user_id);

-- Storage policies (create bucket named "hike-photos" first)
create policy "hike_photos_public_read" on storage.objects
  for select using (bucket_id = 'hike-photos');

create policy "hike_photos_user_write" on storage.objects
  for insert with check (bucket_id = 'hike-photos' and auth.uid() = owner);

create policy "hike_photos_user_delete" on storage.objects
  for delete using (bucket_id = 'hike-photos' and auth.uid() = owner);
